GiftChain is a web app where users can send digital â€œwrapped giftsâ€ to each other.
Each gift includes:

a wrapper image (stored directly in MongoDB)

an optional message

sender & receiver

opened/unopened status

optional blockchain payments (SUI or SOL via Ika)

The website has:

a Send Gift feature

a Received Gifts section (unopened + opened)

a Sent Gifts history

ability to upload custom wrapper images

optional payment flow using

Sui SDK

Ika SDK (Solana MPC signing)

Users authenticate using JWT, and all blockchain operations must run securely on the server.

âœ… TASK: BUILD THE COMPLETE BACKEND

Create a full backend server for GiftChain using the following tech stack:

Node.js

Fastify

TypeScript

MongoDB

JWT authentication

Sui SDK (latest)

Ika SDK (latest)

Dotenv

Zod validation

Bcrypt

Use the latest documentation and latest package versions.

Store wrapper images directly in MongoDB (Buffer)
The server should accept file uploads using Fastify multipart and save them to MongoDB.

âœ… INSTRUCTIONS: DO ALL OF THE FOLLOWING

Generate fully working server code with complete file structure, including:

ğŸ”¹ 1. Full backend folder structure

Organize the project in a scalable, professional structure:

src/
  server.ts
  app.ts
  config/
    env.ts
    db.ts
  middlewares/
    auth.ts
    errorHandler.ts
  routes/
    auth.routes.ts
    gift.routes.ts
    wrapper.routes.ts
    payment.routes.ts
  controllers/
    auth.controller.ts
    gift.controller.ts
    wrapper.controller.ts
    payment.controller.ts
  services/
    auth.service.ts
    gift.service.ts
    wrapper.service.ts
    sui.service.ts
    ika.service.ts
  validations/
    auth.schema.ts
    gift.schema.ts
    wrapper.schema.ts
  models/
    user.model.ts
    gift.model.ts
    wrapper.model.ts
  utils/
    jwt.ts
    hash.ts

ğŸ”¹ 2. Implement all API endpoints with full logic
ğŸ” AUTH

POST /auth/signup

POST /auth/login

POST /auth/refresh-token

GET /auth/me

Use JWT access + refresh tokens.
Password hashing with bcrypt.

ğŸ GIFTS

POST /gifts/send

GET /gifts/sent

GET /gifts/received

GET /gifts/:id

POST /gifts/open/:id

Logic must include:

sender/receiver linking

storing wrapper reference

saving message

marking gift as opened

timestamps

ğŸ¨ WRAPPERS

GET /wrappers

POST /wrappers/upload

Accept multipart file

Store in MongoDB as Buffer or GridFS

Save metadata (name, type, size, userId)

Return wrapper ID

ğŸ’° BLOCKCHAIN â€“ SUI

POST /payments/sui/send

GET /payments/sui/balance

Use Sui SDK latest version
Private keys must be securely stored in .env
NEVER expose to client.

ğŸ’° BLOCKCHAIN â€“ SOL (via Ika MPC)

POST /payments/sol/send

GET /payments/sol/balance

Use Ika SDK latest version with MPC signing:

create dWallet

initialize MPC session

sign a Solana transaction via Ika

broadcast via Solana RPC

Never expose MPC state or keys to the client.

ğŸ”¹ 3. Security Requirements

JWT authentication middleware

Validate every input using Zod

Hash passwords with bcrypt

Store wallet/private/MPC keys in .env

Protect all routes except auth

Input sanitization

Error handling middleware

Rate limit /auth/* routes

Blockchain signing must run ONLY on server

ğŸ”¹ 4. Generate complete source code for ALL FILES

You must output full content of:

every file in src/

config

all controllers

all services

all validation schemas

all MongoDB models (User, Gift, Wrapper with image Buffer/GridFS)

all route definitions

server bootstrap

environment loader

middleware files

package.json

tsconfig.json

.env.example

README.md with full setup instructions

correct TypeScript types for every model & response

Do NOT generate placeholder code.
Provide fully functional, production-ready code.

ğŸ”¹ 5. Use the latest recommended configuration

correct tsconfig

correct Fastify version

correct MongoDB connection

correct multipart handling

correct JWT handling

proper imports

correct TypeScript types everywhere

ğŸ”¹ 6. Output Requirements

Provide entire project structure

Provide complete code for ALL files

Ensure all imports are valid

No missing files or missing exports

Make sure the codebase is fully runnable




















































I want you to set up Zustand in my React client so I can manage all states and make API requests in a clean, scalable way.
My backend is already built inside a server folder, so use the backend routes as the source of truth and design the client state layer around them.

Your job is to:

Create Zustand stores for each backend domain (auth, user, gifts, wrappers, etc.)

Add actions like request message, verify user, fetch wrappers, send gift, etc., based on the backend routes

Make all stores clean, scalable, modular, and production-ready

Use a global API request utility (axios) and integrate it into the store actions

Make sure async actions return proper loading, success, and error states

Use middlewares wherever appropriate

Make the stores easy to import and use inside components/pages

Organize everything properly for future growth

Keep the code consistent and professional

âŒ Do NOT export the entire store
export const useTodoStore = create((set) => ({
  todos: [],
  addTodo: (t) => set((s) => ({ todos: [...s.todos, t] })),
}));

âœ… Export custom hooks with selectors
export const useTodoStore = create((set) => ({
  todos: [],
  addTodo: (t) => set((s) => ({ todos: [...s.todos, t] })),
}));

export const useTodos = () => useTodoStore((s) => s.todos);
export const useAddTodo = () => useTodoStore((s) => s.addTodo);

Separate actions from state ie. Use a stable actions object


























































You are editing my client-side React application.

I already have:

A Received Gifts table

A Sent Gifts table

A Wrapper section showing gift wrappers

A Zustand gift store fetching gifts from backend

Now I want to implement unopened / opened gift experience + a fun bragging modal UI.

ğŸ”¹ Backend Data Assumptions (IMPORTANT)

Each gift object already includes:

status: "sent" â†’ unopened

status: "opened" â†’ opened & claimed

amountUSD

totalTokenAmount (Amount is in SUI Like 1.554 SUI not USD)

wrapper (Wrapper Image URL)

sender / receiver:

username

avatar


âš ï¸ Do NOT make any extra API calls to fetch sender or receiver info, my backend filters and gives username and avatar accordingly.
All required data is already included in the gift object.

ğŸ”¹ Feature Requirements
âœ… 1. Unopened vs Opened Logic

Gifts with status === "sent" â†’ Unopened

Gifts with status === "opened" â†’ Opened / Claimed

Wrapper Section

Show ONLY unopened received gifts

Display the wrapper image

Clicking a wrapper opens the Gift Modal

âœ… 2. Gift Modal (Core Feature)

Create a fun, playful modal (NOT professional looking).

Use:

npm i canvas-confetti

Modal behavior:

Open when:

Clicking an unopened gift wrapper

Clicking any row in Received Gifts table

Clicking any row in Sent Gifts table

Trigger confetti animation when modal opens

âœ… 3. Modal UI Content (Very Important)
ğŸ·ï¸ Header

Show text at the top:
â€œGiftchain.funâ€

Fun typography, playful colors

ğŸ’° Gift Amount (Big & Centered)

Show amount in USD (BIG text)

$12.00


Below it, small text:

â‰ˆ 4.2 SUI

ğŸ‘¤ Sender / Receiver Card

Depending on context:

Received gifts â†’ show Sender

Sent gifts â†’ show Receiver

Card must include:

Avatar image

Username

Wallet address (shortened and this address will be either receiverWallet or senderWallet depending on the context received or sent, for sent show receiver and vice versa)

Copy button (copy full wallet address)

Interaction:

Clicking this card navigates to:

/<username>

âœ… 4. Claim Flow (Mock Only for Now)

If gift is unopened:

Show â€œClaim Giftâ€ button

When clicked:

Trigger confetti animation again

Update UI locally to:

Mark gift as claimed

Replace button with â€œDownload as Imageâ€

âš ï¸ Claiming is frontend-only mock
(no backend integration yet)

âœ… 5. Download as Image (VERY IMPORTANT)

When clicking â€œDownload as Imageâ€:

Download the modal UI as an image

The downloaded image must:

Be an exact visual replica

Same fonts

Same colors

Same layout

Include Giftchain.fun branding

Receiver should be able to share it for bragging rights.

(Use canvas / html-to-image / dom-to-image â€” choose best approach)

âœ… 6. Tables Behavior Update
Sent & Received Gifts Table

Clicking any row opens the same Gift Modal

Modal content adapts automatically:

Sent â†’ show receiver info

Received â†’ show sender info

ğŸ”¹ UI / UX Direction (DO NOT IGNORE)

Make it fun

Make it surprising

Playful colors

Soft animations

Not corporate / not professional

Delight the user

ğŸ”¹ Engineering Constraints

Reuse existing Zustand store

Do NOT break current pagination

Keep code clean & readable

Follow existing project patterns

Avoid unnecessary re-renders

Confetti should not leak memory

ğŸ¯ Final Result

After your changes:

Users clearly see unopened vs opened gifts

Opening a gift feels rewarding

Claiming feels celebratory

Downloaded image is share-worthy

No mock data left for display logic (except mock claim action)